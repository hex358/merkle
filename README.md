# üå≤CertumTree

**CertumTree** is a zero-trust data verification system designed to protect digital information from forgery and manipulation.  
It provides a lightweight, cryptographically secure way to register and verify any digital object (messages, files, documents, API events) with proofs that can be checked independently - even outside the server.

---

## ‚ú® Key Features

- **Zero-Trust Integrity**  
  Data authenticity is recorded in an append-only **Merkle Mountain Range (MMR)** structure.  
  No entity - not even the API owner - can alter past records without detection.

- **Cryptographic Verification**  
  Integrity checks are **bidirectional**:  
  - The server gathers proofs.  
  - Clients verify them independently.  
  This ensures full transparency of every verification step.

- **Public Auditing**  
  Root hashes of the MMR are published every few minutes.  
  Anyone can independently audit the state of the system and confirm no tampering has occurred.

- **Service Registration**  
  Services first register themselves via `register_service`, obtaining a token that binds their metadata.  
  This guarantees authenticity of service information before any data is accepted.

- **Easy Integration**  
  Open API (MIT-licensed) can be embedded directly into applications or business backends to protect users against fraud, phishing, or unauthorized data manipulation.

---

## üóÇ How It Works

1. **Registration**  
   - Users first create an account with `user_signup`.  
   - Services call `register_service` with their username/password to bind identity and metadata.  
   - A token is returned for subsequent interactions.

2. **Blob Formation**  
   - Users or bots can form ‚Äúblobs‚Äù from digital content (messages, files, links).  
   - These blobs are sent to the server, which stores their cryptographic hashes.

3. **Proof & Verification**  
   - To verify, the client requests a proof for the blob.  
   - The server provides a Merkle proof, which the client can validate locally against the published root hash.  
   - Verification works both for businesses embedding CertumTree and for end-users.

---

## üíæ Technology

- **Cryptographic Core:** Merkle Mountain Range (MMR) for append-only proofs  
- **Database Engine:**  
  - CertumTree uses **HexDB** (custom LMDB-based key-value store optimized for constant-length hashes)  
  - Benchmarked at **100M inserts/sec** on Intel i7 (Windows)  
- **APIs & Clients:**  
  - REST API built with Sanic

---

## üåê Frontend

The frontend is served directly by the Sanic application and integrates tightly with the backend:

- **Static Routing (Pathlib + router):**  
  Pages like `/signup`, `/login`, `/dashboard`, `/services`, and `/trees` are rendered as HTML from templates.  
  This provides a lightweight single-page‚Äìlike experience without external frontend frameworks.

- **Search & Discovery (Typesense):**  
  Service discovery uses a fuzzy search engine backed by Typesense integration.  
  Results are cached with TTL for fast repeated queries.  
  Users can filter and page through services dynamically.

- **Interactive Dashboard:**  
  The dashboard shows user services, root hashes, and metadata, with updates coming directly from API calls.  
  Blob verification, service management, and metadata updates are triggered via JSON POST requests.

- **Token & API:**  
  Tokens generated by the backend are retrieved securely via `/get_token`.  
  The frontend uses these to allow blob submission and service actions while keeping user passwords safe.


---

## üìå Example Use Cases

- **Service-to-User Protection**  
  Businesses integrate CertumTree to guarantee that content sent to users is authentic and untampered.  

- **User-Controlled Verification**  
  End-users can register and verify their own data blobs (e.g., legal documents, contracts, personal records).  



---

## üöÄ Getting Started

### 1. Run the Server


### 2. API Endpoints

#### User Signup

```http
POST /user_signup
{
  "username": "alice",
  "password": "secret"
}
````

#### User Login

```http
POST /user_login
{
  "username": "alice",
  "password": "secret"
}
```

#### Register Service

```http
POST /register_service
{
  "username": "alice",
  "password": "secret",
  "service_name": "myservice"
}
```

#### Delete Service

```http
POST /delete_service
{
  "username": "alice",
  "password": "secret",
  "service_name": "myservice"
}
```

#### Update Service Metadata

```http
POST /update_service
{
  "username": "alice",
  "password": "secret",
  "service_name": "myservice",
  "metadata": { "owner": "alice" }
}
```

#### List My Services

```http
POST /get_my_services
{
  "username": "alice"
}
```

#### List Services (with search/filter)

```http
POST /list_services
{
  "username": "alice",
  "filter": "serv",
  "page_id": "1",
  "num_results": "10"
}
```

#### Add Blob

```http
POST /add_blob
{
  "service_name": "alice.myservice",
  "token": "service_token",
  "blob_hash": "0123abcd... (32 hex chars)"
}
```

#### Check Blob

```http
POST /check_blob
{
  "service_name": "alice.myservice",
  "blob_hash": "0123abcd... (32 hex chars)"
}
```

#### Get Root Hash

```http
POST /get_root_hash
{
  "service_name": "alice.myservice"
}
```

#### Get Token

```http
POST /get_token
{
  "username": "alice",
  "password": "secret",
  "service_name": "myservice"
}
```

#### Get Service Metadata

```http
POST /get_service_metadata
{
  "service_name": "alice.myservice"
}
```

#### Has Service

```http
POST /has_service
{
  "service_name": "alice.myservice"
}
```

---

## üõ† Frameworks & Stack

* **Sanic** - Async Python web framework
* **cryptography** - AES-GCM and PBKDF2 for password/token security
* **cachetools** - TTL-based in-memory cache for search results
* **LMDB (via HexDB interface)** - High-performance embedded database
* **Merkle Mountain Range (custom `mmr` module)** - Core data structure for append-only proofs
* **FuzzySearch module** - Parallelized fuzzy search for service discovery
* **Typesense** - Full-text search engine integration for services
* **Pathlib & custom router** - Static asset routing and HTML template serving
* **uuid & secrets** - Token generation and secure randomness

---

## üìä Roadmap

* Add more client SDKs (Rust, Go)
* Visualization dashboard for root hashes & proofs
* Advanced fraud detection workflows (highlighting ‚Äúfake‚Äù mismatches)
* Integration plugins for email, payment, and notification systems

---

## ‚öñ License

MIT License ¬© 2025 CertumTree Project

---

## üéØ Mission

Our goal with CertumTree is to make **trustless verification of digital data** accessible for everyone - from small businesses to individuals.
By removing reliance on central authorities, we protect users from forgery, phishing, and digital fraud in a way that is simple, open, and cryptographically guaranteed.

```

Do you want me to also expand **Frontend** with a visual description (like a short flow of how signup ‚Üí dashboard ‚Üí add blob looks), or keep it just technical?
```
